# Rigid 2D transformation Library
A library for handling transformations in SE(2).



# Conceptual Questions
1. What is the difference between a class and a struct in C++? Member visibility: a class has by default private members, which cannot be accessed by functions outside of the class; the members of a struct can always be accessed (the equivalent of class public members)
2. Why is Vector2D a struct and Transform2D a Class (refer to at least 2 specic C++ core guidelines in your answer)? (1) the x and y members of Vector2D can vary independently depending on how the vector is defined (use struct if the data members can vary independently), while the rotation angle and translation vector can be operated on at the same time if the transformation is multiplied. (2) using classes is a better convention to declare non-public members and encapsulate information (which Transform2D has, while Vector2D does not).
3. Why are some of the constructors in Transform2D explicit (refer to a specific C++ core guideline in your answer)? Some of the constructors in Transform2D only involve one argument and single-argument constructors are declared explicit to avoid unintended conversions that could cast the object to the specified argument type.
4. We need to be able to normalize Vector2D objects (i.e., find the unit vector in the direction of a given Vector2D):
   - Propose three different designs for implementing the normalize functionality: (1) use an external function that takes a reference to a Vector2D object as argument and modifies the object's x and y members; (2) write a method in the Vector2D struct that directly modifies the object's x and y members to get a unit vector; (3) use an external function that takes a reference to a Vector2D object as argument, computes the x and y members needed to get a unit vector, and returns a new Vector2D object initialized as unit vector
   - Discuss the pros and cons of each proposed method, in light of the C++ Core Guidelines. (1) Of all strategies, is the worst at protecting information (x and y members) since it can act on any Vector2D object that has been declared; having the function external is not a good design choice since related data and methods should be organized into structures; pros: it may be useful if multiple struct types need to be normalized as this function could take any of them as argument without having to be redefined as a method in each struct. (2) Matches well the idea of protecting information as this method can only act on its own object, minimizing the risk of data loss. However, directly modifying the original object causes inherent data loss as the user would have to separately store the magnitude of the vector, if this is needed. (3) Pros: minimizes data loss during the operation since the original object remains available; Cons: like the first strategy, it can act on any Vector2D object and does not represent well the related struct members and the normalization method. Additionally, it can cause memory issues since multiple struct variables are now being stored to just keep track of magnitude (which could be stored as a simple type double variable).
   - Which of the methods would you implement and why? I would implement method (2) and also add a method to return the magnitude of the Vector2D object, so that the user can choose when such information can be stored or when only normalizing the original object is needed.
5. Why is Transform2D::inv() declared const while Transform2D::operator\*=() is not (Refer to C++ core guidelines in your answer)? By default, member functions should be const unless they are meant to change the object observable state. This is done to ensure that the risk of member functions accidentally modifying an object due to an erroneous implementation or other circumstances is modified. Transform2D::inv() returns a new Transform2D object and therefore does not modify the current object state, and can remain const; Transform2D::operator\*=() directly modifies the object private members and cannot be const.
